{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/entry.js","webpack:///./src/game.js","webpack:///./src/gamearea.js","webpack:///./src/obstacles.js","webpack:///./src/player.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAA0B;AAC1B;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,6CAAI;AACvB;AACA,CAAC;;;;;;;;;;;;;ACTD;AAAA;AAAkC;AAClC;AACA;AACA;AACA,wBAAwB,iDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,mEAAI,EAAC;;;;;;;;;;;;;ACbpB;AAAA;AAAA;AAAmC;AACL;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,+CAAM;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,kDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACe,uEAAQ,EAAC;;;;;;;;;;;;;ACxGxB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,wEAAS,EAAC;;;;;;;;;;;;;AC1CzB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,qEAAM,EAAC;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/entry.js\");\n","import Game from \"./game\";\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const canvas = document.getElementById(\"myCanvas\");\n  canvas.width = 1200;\n  canvas.height = 500;\n  const ctx = canvas.getContext(\"2d\");\n\n  const game = new Game(ctx);\n  game.startGame();\n});\n","import GameArea from \"./gamearea\";\nclass Game {\n  constructor(ctx) {\n    this.ctx = ctx;\n    this.gamearea = new GameArea(ctx);\n  }\n  //get audio\n  //   var audio = document.getElementById(\"audio\");\n  //   var audio1 = document.getElementById(\"audio1\")\n  startGame() {\n    this.gamearea.start();\n  }\n}\nexport default Game;\n","import Obstacle from \"./obstacles\";\nimport Player from \"./player\";\n\nclass Gamearea {\n  constructor(ctx) {\n    // this.canvas = document.getElementById(\"myCanvas\");\n    //start is intial actions\n    this.context = ctx;\n    this.minGap = 200;\n    this.maxGap = 500;\n    //add Array of obs\n    this.myObstacles = [];\n    this.gap = this.randGap();\n    this.start = this.start.bind(this);\n    this.updateGameArea = this.updateGameArea.bind(this);\n    this.jump = this.jump.bind(this);\n    // this.render = this.render.bind(this);\n  }\n  start() {\n    this.height = 500;\n    this.width = 1200;\n\n    // this.context = this.canvas.getContext(\"2d\");\n    this.player = new Player(this.context);\n    //frame counts how many times 'update gamearea' is ran\n    this.frame = 0;\n    //add score count\n    // this.score = 0;\n\n    //give inital value of score\n    // scoreText.update(\"Score: 0\");\n    //execute \"updateGameArea\" every 5 ms\n    this.interval = setInterval(this.updateGameArea, 5);\n    // this.render();\n    //listener to handle the event of pressing a key in the keyboard\n  }\n  everyinterval(n) {\n    //if frame is a multiple of 'n' we send true\n    if (this.frame % n === 0) return true;\n    return false;\n  }\n  updateGameArea() {\n    //check for a crash\n    for (let i = 0; i < this.myObstacles.length; i++) {\n      if (this.player.crashWidth(this.myObstacles[i])) {\n        this.stop();\n        //exit updateGameArea\n        return;\n      }\n    }\n    //clear game area before each new drawings\n    this.clear();\n\n    //add more obs\n    //After every 150times running 'updateGameArea'\n    // this.player.draw();\n    if (this.everyinterval(this.gap)) {\n      this.myObstacles.push(new Obstacle(this));\n      //update gap after each bew added obs\n      this.gap = this.randGap();\n      //reset frame value\n      this.frame = 0;\n    }\n    for (let i = 0; i < this.myObstacles.length; i++) {\n      //update the obs (x) every time\n      this.myObstacles[i].x -= 1;\n      this.myObstacles[i].draw();\n    }\n    this.player.update();\n    this.frame += 1;\n    //update score\n    // this.score += 0.01;\n    // scoreText.update(\"Score: \" + Math.floor(gamearea.score));\n  }\n\n  jump(e) {\n    if (e.code === \"Space\") {\n      e.preventDefault();\n      this.player.toggleJump();\n    }\n  }\n\n  //define everyinterval\n  clear() {\n    this.context.clearRect(0, 0, this.width, this.height);\n    // this.player.draw();\n  }\n  stop() {\n    clearInterval(this.interval);\n    alert(\"Game Over\");\n    // audio1.play();\n  }\n  randGap() {\n    return Math.floor(\n      this.minGap + Math.random() * (this.maxGap - this.minGap + 1)\n    );\n  }\n\n  // render() {\n  //   // debugger;\n  //   this.player.draw();\n  //   window.requestAnimationFrame(this.render);\n  // }\n}\nexport default Gamearea;\n","class Obstacles {\n  constructor(gamearea) {\n    this.gamearea = gamearea;\n    this.minHeight = 20;\n    this.maxHeight = 100;\n    this.minWidth = 10;\n    this.maxWidth = 20;\n    this.colors = [\n      \"black\",\n      \"red\",\n      \"green\",\n      \"yellow\",\n      \"gray\",\n      \"pink\",\n      \"purple\",\n      \"chocolate\"\n    ];\n    this.height = Math.floor(\n      this.minHeight + Math.random() * (this.maxHeight - this.minHeight + 1)\n    );\n    this.width = Math.floor(\n      this.minWidth + Math.random() * (this.maxWidth - this.minWidth + 1)\n    );\n    this.x = 1200;\n    this.y = this.gamearea.height - this.height;\n    //generate random index\n    this.index = Math.floor(Math.random() * this.colors.length);\n    //now we get the random color\n    this.color = this.colors[this.index];\n    //draw the obstacles\n  }\n\n  draw() {\n    // this.ctx.clearRect(this.x, this.y, this.width, this.height);\n    this.gamearea.context.fillStyle = this.color;\n    this.gamearea.context.fillRect(this.x, this.y, this.width, this.height);\n  }\n}\n//drawing obstacles with random height, width, and coordinates\n//obs height and width is random value btw minHeight and maxHeight/ minWidth and maxWidth\n//gap btw 2 obs are random value btw minGap and maxGap\n\nexport default Obstacles;\n","class Player {\n  constructor(context) {\n    this.ctx = context;\n    this.x = 0;\n    this.y = 441;\n    this.jumping = false;\n    this.runSprite = new Image();\n    this.runSprite.src = \"./assets/images/run.png\";\n    this.frameCount = 19;\n    this.runWidth = 1425 / this.frameCount;\n    this.runHeight = 59;\n    this.jumpSprite = new Image();\n    this.jumpSprite.src = \"./assets/images/jump.png\";\n    this.jumpWidth = 48 / this.frameCount;\n    this.jumpHeight = 80;\n    this.vel = 0;\n    this.currentFrame = 0;\n    //make it jump\n    this.draw = this.draw.bind(this);\n    this.startAnimating();\n    this.update = this.update.bind(this);\n    document.addEventListener(\"keydown\", this.jump.bind(this));\n  }\n\n  //  let srcX;\n  // let xrcY;\n\n  jump() {\n    if (this.jumping === false) {\n      this.jumping = true;\n      const id = setInterval(() => {\n        if (this.y >= 280) {\n          this.y -= 1;\n        } else {\n          const id2 = setInterval(() => {\n            if (this.y <= 441) {\n              this.y += 1;\n            } else {\n              clearInterval(id2);\n              this.jumping = false;\n            }\n          });\n          clearInterval(id);\n        }\n      }, 1);\n\n      // debugger;\n      // const gravity = 0.25;\n      // const bottomY = 280;\n      // if (!this.jumping) {\n      //   if (this.y <= bottomY) {\n      //     this.vel += gravity;\n      //     this.y += this.vel;\n      //   } else {\n      //     this.y = bottomY;\n      //     this.vel = 0;\n      //     this.jumping = false;\n      //   }\n      // }\n    }\n  }\n\n  toggleJump() {\n    if (!this.jumping) {\n      this.jumping = true;\n      this.vel = -8;\n    }\n  }\n  update() {\n    this.currentFrame = ++this.currentFrame % this.frameCount;\n    this.srcX = this.currentFrame * this.runWidth;\n    this.srcY = 0;\n  }\n\n  draw() {\n    const now = Date.now();\n    const elapsed = now - this.then;\n\n    if (elapsed > this.fpsInterval) {\n      this.update();\n      this.ctx.clearRect(this.x, 0, this.runWidth, 1000);\n      this.then = now - (elapsed % this.fpsInterval);\n      this.ctx.drawImage(\n        this.runSprite,\n        this.srcX,\n        this.srcY,\n        this.runWidth,\n        this.runHeight,\n        this.x,\n        this.y,\n        this.runWidth,\n        this.runHeight\n      );\n    }\n    window.requestAnimationFrame(this.draw);\n  }\n\n  startAnimating() {\n    this.fpsInterval = 1000 / 10;\n    this.then = Date.now();\n    this.startTime = this.then;\n    this.draw();\n  }\n\n  //crash happens when the coordinates of the player and the obs overlap\n\n  crashWidth(obs) {\n    if (\n      this.x + 30 > obs.x &&\n      this.x < obs.x + obs.width &&\n      this.y + 30 > obs.y\n    ) {\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default Player;\n\n// class dk {\n//   constructor(ctx) {\n//     this.ctx = ctx;\n//     this.image = new Image();\n//     this.image.src = \"../assets/images/dkrun.png\";\n//     this.sprite = new Sprite(this.image, sx, sy, sw, sh, dx, dy, dw, dh);\n//     // remember to update your dy as your object moves up and down\n//     this.frameTimer = 0;\n//     this.animationSpeed = 30;\n//     // frameTimer and animationSpeed controls frames per second\n//     this.currentFrame = 0;\n//   }\n\n//   update(dy) {}\n\n//   draw() {\n//     this.frameTimer++;\n//     // increments every time you run requestAnimationFrame\n//     if (this.frameTimer % this.animationSpeed === 0) {\n//       this.currentFrame = (this.currentFrame + 1) % 20;\n//     }\n//     // will go to next sprite when true\n\n//     this.ctx.drawImage(\n//       this.image,\n//       sx * this.currentFrame,\n//       sy,\n//       sw,\n//       sh,\n//       dx,\n//       dy,\n//       dw,\n//       dh\n//     );\n//   }\n// }\n"],"sourceRoot":""}