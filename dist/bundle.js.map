{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/entry.js","webpack:///./src/game.js","webpack:///./src/gamearea.js","webpack:///./src/obstacles.js","webpack:///./src/player.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAA0B;AAC1B;AACA,mBAAmB,6CAAI;AACvB;AACA,CAAC;;;;;;;;;;;;;ACJD;AAAA;AAAkC;AAClC;AACA;AACA,wBAAwB,iDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,mEAAI,EAAC;;;;;;;;;;;;;ACZpB;AAAA;AAAA;AAAmC;AACL;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,+CAAM;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,uEAAQ,EAAC;;;;;;;;;;;;;ACpFxB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,wEAAS,EAAC;;;;;;;;;;;;;ACzCzB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,qEAAM,EAAC;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/entry.js\");\n","import Game from \"./game\";\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const game = new Game();\n  game.startGame();\n});\n","import GameArea from \"./gamearea\";\nclass Game {\n  constructor() {\n    this.gamearea = new GameArea();\n  }\n  //get audio\n  //   var audio = document.getElementById(\"audio\");\n  //   var audio1 = document.getElementById(\"audio1\")\n  startGame() {\n    this.gamearea.start();\n  }\n}\nexport default Game;\n","import Obstacle from \"./obstacles\";\nimport Player from \"./player\";\n\nclass Gamearea {\n  constructor() {\n    this.canvas = document.getElementById(\"myCanvas\");\n    //start is intial actions\n    this.minGap = 200;\n    this.maxGap = 500;\n    //add Array of obs\n    this.myObstacles = [];\n    this.gap = this.randGap();\n    this.start = this.start.bind(this);\n    this.updateGameArea = this.updateGameArea.bind(this);\n  }\n  start() {\n    this.canvas.height = 400;\n    this.canvas.width = 800;\n\n    this.context = this.canvas.getContext(\"2d\");\n    this.player = new Player(this.context);\n    //frame counts how many times 'update gamearea' is ran\n    this.frame = 0;\n    //add score count\n    // this.score = 0;\n\n    //give inital value of score\n    // scoreText.update(\"Score: 0\");\n    //execute \"updateGameArea\" every 5 ms\n    this.interval = setInterval(this.updateGameArea, 5);\n    //listener to handle the event of pressing a key in the keyboard\n  }\n  everyinterval(n) {\n    //if frame is a multiple of 'n' we send true\n    if (this.frame % n === 0) return true;\n    return false;\n  }\n  updateGameArea() {\n    //check for a crash\n    for (let i = 0; i < this.myObstacles.length; i++) {\n      if (this.player.crashWidth(this.myObstacles[i])) {\n        this.stop();\n        //exit updateGameArea\n        return;\n      }\n    }\n    //clear game area before each new drawings\n    this.clear();\n    //add more obs\n    //After every 150times running 'updateGameArea'\n    if (this.everyinterval(this.gap)) {\n      this.myObstacles.push(new Obstacle(this));\n      //update gap after each bew added obs\n      this.gap = this.randGap();\n      //reset frame value\n      this.frame = 0;\n    }\n    for (let i = 0; i < this.myObstacles.length; i++) {\n      //update the obs (x) every time\n      this.myObstacles[i].x -= 1;\n      this.myObstacles[i].draw();\n    }\n    this.player.newPos();\n    this.player.update();\n    this.frame += 1;\n    //update score\n    // this.score += 0.01;\n    // scoreText.update(\"Score: \" + Math.floor(gamearea.score));\n  }\n  //define everyinterval\n  clear() {\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n  stop() {\n    clearInterval(this.interval);\n    alert(\"Game Over\");\n    // audio1.play();\n  }\n  randGap() {\n    return Math.floor(\n      this.minGap + Math.random() * (this.maxGap - this.minGap + 1)\n    );\n  }\n}\nexport default Gamearea;\n","class Obstacles {\n  constructor(gamearea) {\n    this.gamearea = gamearea;\n    this.minHeight = 20;\n    this.maxHeight = 100;\n    this.minWidth = 10;\n    this.maxWidth = 20;\n    this.colors = [\n      \"black\",\n      \"red\",\n      \"green\",\n      \"yellow\",\n      \"gray\",\n      \"pink\",\n      \"purple\",\n      \"chocolate\"\n    ];\n    this.height = Math.floor(\n      this.minHeight + Math.random() * (this.maxHeight - this.minHeight + 1)\n    );\n    this.width = Math.floor(\n      this.minWidth + Math.random() * (this.maxWidth - this.minWidth + 1)\n    );\n    this.x = 1200;\n    this.y = this.gamearea.canvas.height - this.height;\n    //generate random index\n    this.index = Math.floor(Math.random() * this.colors.length);\n    //now we get the random color\n    this.color = this.colors[this.index];\n    //draw the obstacles\n  }\n\n  draw() {\n    this.gamearea.context.fillStyle = this.color;\n    this.gamearea.context.fillRect(this.x, this.y, this.width, this.height);\n  }\n}\n//drawing obstacles with random height, width, and coordinates\n//obs height and width is random value btw minHeight and maxHeight/ minWidth and maxWidth\n//gap btw 2 obs are random value btw minGap and maxGap\n\nexport default Obstacles;\n","class Player {\n  constructor(context) {\n    this.context = context;\n    this.x = 100;\n    this.y = 470;\n    //make it jump\n    this.speedY = 0;\n    window.addEventListener(\"keydown\", this.jump.bind(this));\n  }\n  //jumping is a changing of y-pos upward until reaching a given peak, then coming back down\n  jump() {\n    this.speedY = -2;\n    //play the audio in the 'jump' function\n    // audio.play();\n  }\n  //draw the player\n  update() {\n    //dye the 'player' black otherwise it will be gray\n    this.context.fillStyle = \"indigo\";\n    this.context.fillRect(this.x, this.y, 30, 30);\n  }\n  newPos() {\n    //it goes down if it 'y' reaches 280\n    if (this.y < 280) {\n      this.speedY = 2;\n    }\n    this.y = this.y + this.speedY;\n\n    //it stops going down if it reaches 470\n    if (this.speedY === 2 && this.y === 470) {\n      this.speedY = 0;\n    }\n  }\n\n  //crash happens when the coordinates of the player and the obs overlap\n\n  crashWidth(obs) {\n    if (\n      this.x + 30 > obs.x &&\n      this.x < obs.x + obs.width &&\n      this.y + 30 > obs.y\n    ) {\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default Player;\n\n// class dk {\n//   constructor(ctx) {\n//     this.ctx = ctx;\n//     this.image = new Image();\n//     this.image.src = \"../assets/images/dkrun.png\";\n//     this.sprite = new Sprite(this.image, sx, sy, sw, sh, dx, dy, dw, dh);\n//     // remember to update your dy as your object moves up and down\n//     this.frameTimer = 0;\n//     this.animationSpeed = 30;\n//     // frameTimer and animationSpeed controls frames per second\n//     this.currentFrame = 0;\n//   }\n\n//   update(dy) {}\n\n//   draw() {\n//     this.frameTimer++;\n//     // increments every time you run requestAnimationFrame\n//     if (this.frameTimer % this.animationSpeed === 0) {\n//       this.currentFrame = (this.currentFrame + 1) % 20;\n//     }\n//     // will go to next sprite when true\n\n//     this.ctx.drawImage(\n//       this.image,\n//       sx * this.currentFrame,\n//       sy,\n//       sw,\n//       sh,\n//       dx,\n//       dy,\n//       dw,\n//       dh\n//     );\n//   }\n// }\n"],"sourceRoot":""}